Para los siguientes casos de prueba, se acotó en .data las variables utilizadas al mostrar el ejemplo.
como asi tambien se acotó la seccion del main y/o procedemientos.
----------------------------------------------------------
%% Asignacion LONGINT:
Caso de prueba: 
    LONGINT a,b;
    a = b;

Salida ASM:
    .data
    _b@main dd ?
    _a@main dd ?
    .code
    START:
    START:
    MOV EAX, _b@main
    MOV _a@main, EAX
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Asignacion FLOAT:
Caso de prueba: 
    FLOAT a,b; 
    a = b;

Salida ASM:
    .data
    _b@main dd ?
    _a@main dd ?
    .code
    START:
    FLD _b@main
    FSTP _a@main
    invoke ExitProcess, 0
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    FLOAT a,b,c; 
    a = b/c;

Salida ASM:
    .data
    ERROR_DIVISION_CERO db "Error: no es posible divir por cero."
    FLOAT_CERO DQ 0.0
    @aux DD ?
    _b@main dd ?
    _a@main dd ?
    _c@main dd ?
    _@aux0 dd ?
    .code
    START:
    FLD _b@main
    FLD _c@main
    FLD FLOAT_CERO
    FCOMP
    FSTSW AX
    SAHF
    JE __etiquetaErrorDivCero__
    FDIV
    FSTP _@aux0
    FLD _@aux0
    FSTP _a@main
    invoke ExitProcess, 0
    __etiquetaErrorDivCero__:
    invoke MessageBox, NULL, addr ERROR_DIVISION_CERO, addr ERROR_DIVISION_CERO, MB_OK
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a,b,c;
    a = b/c;

Salida ASM:
    .data
    ERROR_DIVISION_CERO db "Error: no es posible divir por cero."
    FLOAT_CERO DQ 0.0
    _b@main dd ?
    _a@main dd ?
    _c@main dd ?
    .code
    START:
    MOV EBX, _c@main
    MOV EAX, _b@main
    CDQ
    CMP EBX , 0
    JE __etiquetaErrorDivCero__
    IDIV EBX
    MOV _a@main, EAX
    invoke ExitProcess, 0
    __etiquetaErrorDivCero__:
    invoke MessageBox, NULL, addr ERROR_DIVISION_CERO, addr ERROR_DIVISION_CERO, MB_OK
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a,b,c;
    a = b*c;
    
Salida ASM:
    .data
    _b@main dd ?
    _a@main dd ?
    _c@main dd ?
    .code
    START:
    MOV EAX, _b@main
    IMUL EAX, _c@main
    MOV _a@main, EAX
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    FLOAT a,b,c;
    a = b*c;

Salida ASM:
    .data
    _b@main dd ?
    _a@main dd ?
    _c@main dd ?
    _@aux0 dd ?
    .code
    START:
    FLD _b@main
    FLD _c@main
    FMUL 
    FSTP _@aux0
    FLD _@aux0
    FSTP _a@main
    invoke ExitProcess, 0
    END START

----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    FLOAT a,b,c;
    a = b + c;

Salida ASM:
    .data
    ERROR_OVERFLOW_SUMA db "Error: overflow en suma."
    MINIMO_POSITIVO DQ 1.17549435f-38
    MINIMO_NEGATIVO DQ -1.17549435f-38
    MAXIMO_POSITIVO DQ 3.40282347f38
    MAXIMO_NEGATIVO DQ -3.40282347f38
    @aux DD ?
    _b@main dd ?
    _a@main dd ?
    _c@main dd ?
    _@aux0 dd ?
    .code
    START:
    FLD _b@main
    FADD _c@main
    FST @aux
    CALL OVERFLOW_FLOAT
    FSTP _@aux0
    FLD _@aux0
    FSTP _a@main
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    __etiquetaErrorDivCero__:
    invoke MessageBox, NULL, addr ERROR_DIVISION_CERO, addr ERROR_DIVISION_CERO, MB_OK
    invoke ExitProcess, 0
    FLOAT_VALIDO:
    RET
    OVERFLOW_FLOAT:
    FINIT
    FLD @aux
    FCOM MAXIMO_POSITIVO
    FSTSW AX
    SAHF
    JA __etiquetaErrorOverflow__
    FINIT
    FLD @aux
    FCOM MINIMO_POSITIVO
    FSTSW AX
    SAHF
    JA FLOAT_VALIDO
    FINIT
    FLD @aux
    FCOM MAXIMO_NEGATIVO
    FSTSW AX
    SAHF
    JB __etiquetaErrorOverflow__
    FINIT
    FLD @aux
    FCOM MINIMO_NEGATIVO
    FSTSW AX
    SAHF
    JB FLOAT_VALIDO
    FINIT
    FLD @aux
    FCOM FLOAT_CERO
    FSTSW AX
    SAHF
    JE FLOAT_VALIDO
    JMP __etiquetaErrorOverflow__
    END START



----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a,b,c;
    a = b + c;

Salida ASM:
    .data
    _b@main dd ?
    _a@main dd ?
    _c@main dd ?
    .code
    START:
    MOV EAX, _b@main
    ADD EAX, _c@main
    JO __etiquetaErrorOverflow__
    MOV _a@main, EAX
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a,b,c;
    a = b - c;

Salida ASM:
   .data
    _b@main dd ?
    _a@main dd ?
    _c@main dd ?
    .code
    START:
    MOV EAX, _b@main
    SUB EAX, _c@main
    MOV _a@main, EAX
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
   FLOAT a,b,c;
   a = b-c;

Salida ASM:
   .data
    _b@main dd ?
    _a@main dd ?
    _c@main dd ?
    _@aux0 dd ?
    .code
    START:
    FLD _b@main
    SUB _c@main
    FSTP _@aux0
    MOV EAX, _@aux0
    MOV _a@main, EAX
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    OUT("cadena a imprimir");

Salida ASM:
   .data
_Cadena0 db "cadena a imprimir", 0
    .code
    START:
    invoke MessageBox, NULL, addr _Cadena0, addr  _Cadena0, MB_OK
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a , b ;
    a = 3_l + b;

Salida ASM:
   .data
    _Constante0 dd 3
    _b@main dd ?
    _a@main dd ?
    .code
    START:
    MOV EAX, _Constante0
    ADD EAX, _b@main
    JO __etiquetaErrorOverflow__
    MOV _a@main, EAX
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    FLOAT a , b ; %%TODO:
    a = 3.45f-2 / b; %%TODO:

Salida ASM:
  .data
    ERROR_DIVISION_CERO db "Error: no es posible divir por cero."
    FLOAT_CERO DQ 0.0
    _b@main dd ?
    _a@main dd ?
    _Constante0 dd 3.45f-2
    _@aux0 dd ?
    .code
    START:
    FLD _Constante0
    FLD _b@main
    FLD FLOAT_CERO
    FCOMP
    FSTSW AX
    SAHF
    JE __etiquetaErrorDivCero__
    FDIV
    FSTP _@aux0
    MOV EAX, _@aux0
    MOV _a@main, EAX
    invoke ExitProcess, 0
    __etiquetaErrorDivCero__:
    invoke MessageBox, NULL, addr ERROR_DIVISION_CERO, addr ERROR_DIVISION_CERO, MB_OK
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
   FLOAT a , b, c ; %%TODO:
    IF ( a - b > c + 1.0 ) {
        a  = b;
    } END_IF ;
    OUT("termine de comparar");

Salida ASM: %% ERROR_OVERFLOW_SUMA es igual a los anteriores (solo lo quitamos por comodidad en el txt)
   .data
    ERROR_OVERFLOW_SUMA db "Error: overflow en suma."
    MINIMO_POSITIVO DQ 1.17549435f-38
    MINIMO_NEGATIVO DQ -1.17549435f-38
    MAXIMO_POSITIVO DQ 3.40282347f38
    MAXIMO_NEGATIVO DQ -3.40282347f38
    @aux DD ?
    _Constante0 dd 1.0
    _b@main dd ?
    _a@main dd ?
    _c@main dd ?
    _Cadena0 db "termine de comparar", 0
    _@aux1 dd ?
    _@aux0 dd ?
    .code
    START:
    FLD _a@main
    SUB _b@main
    FSTP _@aux0
    FLD _c@main
    FADD _Constante0
    FST @aux
    CALL OVERFLOW_FLOAT
    FSTP _@aux1
    MOV EAX , _@aux0
    CMP EAX , _@aux1
    JNG L14
    MOV EAX, _b@main
    MOV _a@main, EAX
    JMP L15
    L14:
    L15:
    invoke MessageBox, NULL, addr _Cadena0, addr  _Cadena0, MB_OK
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    FLOAT a , b, c ; %%TODO:
    IF ( a - b != c + 1.0 ) {
        a  = b + c;
    } ELSE { 
        a = b - c;
    } END_IF ;

Salida ASM:
   .data
    ERROR_DIVISION_CERO db "Error: no es posible divir por cero."
    ERROR_OVERFLOW_SUMA db "Error: overflow en suma."
    FLOAT_CERO DQ 0.0
    MINIMO_POSITIVO DQ 1.17549435f-38
    MINIMO_NEGATIVO DQ -1.17549435f-38
    MAXIMO_POSITIVO DQ 3.40282347f38
    MAXIMO_NEGATIVO DQ -3.40282347f38
    @aux DD ?
    _x1@main dd ?
    _b@main dd ?
    _a@main dd ?
    _x2@main dd ?
    _Constante0 dd 2
    _Constante1 dd 1.0
    _Constante2 dd 4
    _x3@main dd ?
    _@aux3 dd ?
    _@aux2 dd ?
    _c@main dd ?
    _@aux1 dd ?
    _@aux0 dd ?
    .code
    START:
    FLD _a@main
    SUB _b@main
    FSTP _@aux0
    FLD _c@main
    FADD _Constante1
    FST @aux
    CALL OVERFLOW_FLOAT
    FSTP _@aux1
    MOV EAX , _@aux0
    CMP EAX , _@aux1
    JE L16
    FLD _b@main
    FADD _c@main
    FST @aux
    CALL OVERFLOW_FLOAT
    FSTP _@aux2
    MOV EAX, _@aux2
    MOV _a@main, EAX
    JMP L22
    L16:
    FLD _b@main
    SUB _c@main
    FSTP _@aux3
    MOV EAX, _@aux3
    MOV _a@main, EAX
    L22:
    MOV EAX, _Constante2
    MOV _x1@main, EAX
    MOV EAX, _Constante0
    MOV _x2@main, EAX
    MOV EAX, _x1@main
    ADD EAX, _x2@main
    JO __etiquetaErrorOverflow__
    ADD EAX, _Constante2
    JO __etiquetaErrorOverflow__
    MOV _x3@main, EAX
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    __etiquetaErrorDivCero__:
    invoke MessageBox, NULL, addr ERROR_DIVISION_CERO, addr ERROR_DIVISION_CERO, MB_OK
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a, b , c;
    a = b + 3_l;

    OUT("comienza");

    IF ( a == 0_l ) {
        a  = b;
        IF ( b == 0_l ) {	
            c = 1_l;
        } END_IF;
    } END_IF;

OUT("termina");
Salida ASM:
   .data
    _Constante0 dd 0
    _Constante1 dd 1
    _Constante2 dd 3
    _b@main dd ?
    _a@main dd ?
    _Cadena0 db "comienza", 0
    _Cadena1 db "termina", 0
    _c@main dd ?
    .code
    START:
    MOV EAX, _b@main
    ADD EAX, _Constante2
    JO __etiquetaErrorOverflow__
    MOV _a@main, EAX
    invoke MessageBox, NULL, addr _Cadena0, addr  _Cadena0, MB_OK
    MOV EAX , _a@main
    CMP EAX , _Constante0
    JNE L29
    MOV EAX, _b@main
    MOV _a@main, EAX
    MOV EAX , _b@main
    CMP EAX , _Constante0
    JNE L25
    MOV EAX, _Constante1
    MOV _c@main, EAX
    JMP L26
    L25:
    L26:
    JMP L30
    L29:
    L30:
    invoke MessageBox, NULL, addr _Cadena1, addr  _Cadena1, MB_OK
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
   FLOAT a, b , c; %%TODO:
    IF ( a - b > c + 1.0 ) {
        OUT("hola como andas");
    } END_IF ;

Salida ASM:
    .data
    ERROR_OVERFLOW_SUMA db "Error: overflow en suma."
    MINIMO_POSITIVO DQ 1.17549435f-38
    MINIMO_NEGATIVO DQ -1.17549435f-38
    MAXIMO_POSITIVO DQ 3.40282347f38
    MAXIMO_NEGATIVO DQ -3.40282347f38
    @aux DD ?
    _Cadena0 db "hola como andas", 0
    _Constante0 dd 1.0
    _b@main dd ?
    _a@main dd ?
    _c@main dd ?
    _@aux1 dd ?
    _@aux0 dd ?
   .code
    START:
    FLD _a@main
    SUB _b@main
    FSTP _@aux0
    FLD _c@main
    FADD _Constante0
    FST @aux
    CALL OVERFLOW_FLOAT
    FSTP _@aux1
    MOV EAX , _@aux0
    CMP EAX , _@aux1
    JNG L13
    invoke MessageBox, NULL, addr _Cadena0, addr  _Cadena0, MB_OK
    JMP L14
    L13:
    L14:
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a, b, x;
    WHILE (a > b) LOOP {
        x = 3_l;
    };

Salida ASM:
    .data
    _Constante0 dd 3
    _b@main dd ?
    _a@main dd ?
    _x@main dd ?
    .code
    START:
    L0:
    MOV EAX , _a@main
    CMP EAX , _b@main
    JNG L11
    MOV EAX, _Constante0
    MOV _x@main, EAX
    JMP L0
    L11:
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
   LONGINT a, b;
    WHILE (a>b) LOOP {
        IF (a==b){
            OUT("adentro if");
        } END_IF;
    };

Salida ASM:
    .data
    _Cadena0 db "adentro if", 0
    _b@main dd ?
    _a@main dd ?
    .code
    START:
    L0:
    MOV EAX , _a@main
    CMP EAX , _b@main
    JNG L19
    MOV EAX , _a@main
    CMP EAX , _b@main
    JNE L15
    invoke MessageBox, NULL, addr _Cadena0, addr  _Cadena0, MB_OK
    JMP L16
    L15:
    L16:
    JMP L0
    L19:
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    FLOAT x1; %%TODO:
    x1 = 2_l; 

Salida ASM:
    .data
    _x1@main dd ?
    _Constante0 dd 2
    _@aux0 dd ?
    .code
    START:
    MOV EAX, _Constante0
    MOV _@aux0, EAX
    FILD _@aux0
    FSTP _@aux0
    MOV EAX, _@aux0
    MOV _x1@main, EAX
    invoke ExitProcess, 0
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT c;
    FLOAT x1, x2 ;  %%TODO:
    x1 = x2 + c; 

Salida ASM:
    .data
    ERROR_OVERFLOW_SUMA db "Error: overflow en suma."
    MINIMO_POSITIVO DQ 1.17549435f-38
    MINIMO_NEGATIVO DQ -1.17549435f-38
    MAXIMO_POSITIVO DQ 3.40282347f38
    MAXIMO_NEGATIVO DQ -3.40282347f38
    @aux DD ?
    _x1@main dd ?
    _x2@main dd ?
    _c@main dd ?
    _@aux1 dd ?
    _@aux0 dd ?
    .code
    START:
    MOV EAX, _c@main
    MOV _@aux0, EAX
    FILD _@aux0
    FSTP _@aux0
    FLD _x2@main
    FADD _@aux0
    FST @aux
    CALL OVERFLOW_FLOAT
    FSTP _@aux1
    MOV EAX, _@aux1
    MOV _x1@main, EAX
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    END START

----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT c;
    FLOAT x1, x2 ;  %%TODO:
    x1 = c + x2;

Salida ASM:
    .data
    ERROR_OVERFLOW_SUMA db "Error: overflow en suma."
    FLOAT_CERO DQ 0.0
    MINIMO_POSITIVO DQ 1.17549435f-38
    MINIMO_NEGATIVO DQ -1.17549435f-38
    MAXIMO_POSITIVO DQ 3.40282347f38
    MAXIMO_NEGATIVO DQ -3.40282347f38
    @aux DD ?
    _x1@main dd ?
    _x2@main dd ?
    _c@main dd ?
    _@aux1 dd ?
    _@aux0 dd ?
    .code
    START:
    MOV EAX, _c@main
    MOV _@aux0, EAX
    FILD _@aux0
    FSTP _@aux0
    FLD _@aux0
    FADD _x2@main
    FST @aux
    CALL OVERFLOW_FLOAT
    FSTP _@aux1
    MOV EAX, _@aux1
    MOV _x1@main, EAX
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    END START

----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a, b , c;
    FLOAT x1, x2 ;  
    a = 4_l;
    b = 5_l;
    x2 = -3.0f+23; 
    c = a * b + -5_l;
    OUT("conversion implicita longint en suma y division");
    x1 = a / 2.0 + b ;
    OUT("finalizo division"); 

Salida ASM:
    .386
    .model flat, stdcall
    option casemap :none
    include \masm32\include\windows.inc
    include \masm32\include\kernel32.inc
    include \masm32\include\user32.inc
    includelib \masm32\lib\kernel32.lib
    includelib \masm32\lib\user32.lib
    .data
    ERROR_DIVISION_CERO db "Error: no es posible divir por cero.", 0
    ERROR_OVERFLOW_SUMA db "Error: overflow en suma.", 0
    FLOAT_CERO DQ 0.0
    MINIMO_POSITIVO DQ 1.17549435e-38
    MINIMO_NEGATIVO DQ -1.17549435e-38
    MAXIMO_POSITIVO DQ 3.40282347e38
    MAXIMO_NEGATIVO DQ -3.40282347e38
    @aux DD ?
    _x1@main dd ?
    _b@main dd ?
    _a@main dd ?
    _Constante0 dd -5
    _x2@main dd ?
    _Cadena0 db "finalizo division", 0
    _Constante1 dd -3.0f+23
    _Cadena1 db "conversion implicita longint en suma y division", 0
    _Constante2 dd 4
    _Constante3 dd 2.0
    _Constante4 dd 5
    _@aux3 dd ?
    _@aux2 dd ?
    _c@main dd ?
    _@aux1 dd ?
    _@aux0 dd ?
    .code
    START:
    MOV EAX, _Constante2
    MOV _a@main, EAX
    MOV EAX, _Constante4
    MOV _b@main, EAX
    FLD _Constante1
    FSTP _x2@main
    MOV EAX, _a@main
    IMUL EAX, _b@main
    ADD EAX, _Constante0
    JO __etiquetaErrorOverflow__
    MOV _c@main, EAX
    invoke MessageBox, NULL, addr _Cadena1, addr  _Cadena1, MB_OK
    MOV EAX, _a@main
    MOV _@aux0, EAX
    FILD _@aux0
    FSTP _@aux0
    FLD _@aux0
    FLD _Constante3
    FLD FLOAT_CERO
    FCOMP
    FSTSW AX
    SAHF
    JE __etiquetaErrorDivCero__
    FDIV
    FSTP _@aux1
    MOV EAX, _b@main
    MOV _@aux2, EAX
    FILD _@aux2
    FSTP _@aux2
    FLD _@aux1
    FADD _@aux2
    FST @aux
    CALL OVERFLOW_FLOAT
    FSTP _@aux3
    FLD _@aux3
    FSTP _x1@main
    invoke MessageBox, NULL, addr _Cadena0, addr  _Cadena0, MB_OK
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    __etiquetaErrorDivCero__:
    invoke MessageBox, NULL, addr ERROR_DIVISION_CERO, addr ERROR_DIVISION_CERO, MB_OK
    invoke ExitProcess, 0
    OVERFLOW_FLOAT:
    FINIT
    FLD @aux
    FCOM MAXIMO_POSITIVO
    FSTSW AX
    SAHF
    JA __etiquetaErrorOverflow__
    FINIT
    FLD @aux
    FCOM MINIMO_POSITIVO
    FSTSW AX
    SAHF
    JA FLOAT_VALIDO
    FINIT
    FLD @aux
    FCOM MAXIMO_NEGATIVO
    FSTSW AX
    SAHF
    JB __etiquetaErrorOverflow__
    FINIT
    FLD @aux
    FCOM MINIMO_NEGATIVO
    FSTSW AX
    SAHF
    JB FLOAT_VALIDO
    FINIT
    FLD @aux
    FCOM FLOAT_CERO
    FSTSW AX
    SAHF
    JE FLOAT_VALIDO
    JMP __etiquetaErrorOverflow__
    FLOAT_VALIDO:
    RET
    END START

----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a,b;
    a = b; 
    PROC procedimiento() NI = 3_l {
        LONGINT a,b;
        a = b;
    };
    procedimiento();

Salida ASM:
    .data
    _a@main@procedimiento dd ?
    _Constante0 dd 3
    _b@main dd ?
    _b@main@procedimiento dd ?
    _a@main dd ?
    .code
    START:
    MOV EAX, _b@main
    MOV _a@main, EAX
    CALL procedimiento@main
    invoke ExitProcess, 0
    procedimiento@main:
    MOV EAX, _b@main@procedimiento
    MOV _a@main@procedimiento, EAX
    RET
    END START

----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a,b;
    a = b; 
    PROC procedimiento() NI = 3_l {
        LONGINT a,b;
        a = b;
        PROC invocacion() NI = 2_l {
            b = a;	
            PROC procedimiento() NI = 1_l {
                b = a;
            };
            procedimiento();
        };
        invocacion();
    };
    procedimiento();

Salida ASM:
    .data
    _a@main@procedimiento dd ?
    _Constante0 dd 1
    _Constante1 dd 2
    _Constante2 dd 3
    _b@main dd ?
    _b@main@procedimiento dd ?
    _a@main dd ?
    .code
    START:
    MOV EAX, _b@main
    MOV _a@main, EAX
    CALL procedimiento@main
    invoke ExitProcess, 0
    procedimiento@main@procedimiento@invocacion:
    MOV EAX, _a@main@procedimiento
    MOV _b@main@procedimiento, EAX
    RET
    invocacion@main@procedimiento:
    MOV EAX, _a@main@procedimiento
    MOV _b@main@procedimiento, EAX
    CALL procedimiento@main@procedimiento@invocacion
    RET
    procedimiento@main:
    MOV EAX, _b@main@procedimiento
    MOV _a@main@procedimiento, EAX
    CALL invocacion@main@procedimiento
    RET
    END START
----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a,b;
    a = 3_l; 
    b = 4_l;
    FLOAT w; 
    w = 2.0;
    PROC procedimiento(FLOAT x, LONGINT z) NI = 3_l { 
        LONGINT a,b;
        FLOAT c; 
        a = b;
        c = x * z;
        PROC invocacion() NI = 2_l {
            b = a;	
            PROC procedimiento() NI = 1_l {
                b = a;
            };
            procedimiento();
        };
        invocacion();
    };
procedimiento(z:b,x:w);

Salida ASM:
   .386
    .model flat, stdcall
    option casemap :none
    include \masm32\include\windows.inc
    include \masm32\include\kernel32.inc
    include \masm32\include\user32.inc
    includelib \masm32\lib\kernel32.lib
    includelib \masm32\lib\user32.lib
    .data
    ERROR_DIVISION_CERO db "Error: no es posible divir por cero.", 0
    ERROR_OVERFLOW_SUMA db "Error: overflow en suma.", 0
    FLOAT_CERO DQ 0.0
    MINIMO_POSITIVO DQ 1.17549435e-38
    MINIMO_NEGATIVO DQ -1.17549435e-38
    MAXIMO_POSITIVO DQ 3.40282347e38
    MAXIMO_NEGATIVO DQ -3.40282347e38
    @aux DD ?
    _a@main@procedimiento dd ?
    _x@main@procedimiento dd ?
    _b@main dd ?
    _b@main@procedimiento dd ?
    _a@main dd ?
    _z@main@procedimiento dd ?
    _w@main dd ?
    _Constante0 dd 1
    _Constante1 dd 2
    _Constante2 dd 3
    _Constante3 dd 4
    _Constante4 dd 2.0
    _c@main@procedimiento dd ?
    _@aux1 dd ?
    _@aux0 dd ?
    .code
    START:
    MOV EAX, _Constante2
    MOV _a@main, EAX
    MOV EAX, _Constante3
    MOV _b@main, EAX
    FLD _Constante4
    FSTP _w@main
    MOV EAX, _b@main
    MOV _z@main@procedimiento, EAX
    FLD _w@main
    FSTP _x@main@procedimiento
    CALL procedimiento@main
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    __etiquetaErrorDivCero__:
    invoke MessageBox, NULL, addr ERROR_DIVISION_CERO, addr ERROR_DIVISION_CERO, MB_OK
    invoke ExitProcess, 0
    OVERFLOW_FLOAT:
    FINIT
    FLD @aux
    FCOM MAXIMO_POSITIVO
    FSTSW AX
    SAHF
    JA __etiquetaErrorOverflow__
    FINIT
    FLD @aux
    FCOM MINIMO_POSITIVO
    FSTSW AX
    SAHF
    JA FLOAT_VALIDO
    FINIT
    FLD @aux
    FCOM MAXIMO_NEGATIVO
    FSTSW AX
    SAHF
    JB __etiquetaErrorOverflow__
    FINIT
    FLD @aux
    FCOM MINIMO_NEGATIVO
    FSTSW AX
    SAHF
    JB FLOAT_VALIDO
    FINIT
    FLD @aux
    FCOM FLOAT_CERO
    FSTSW AX
    SAHF
    JE FLOAT_VALIDO
    JMP __etiquetaErrorOverflow__
    FLOAT_VALIDO:
    RET
    procedimiento@main@procedimiento@invocacion:
    MOV EAX, _a@main@procedimiento
    MOV _b@main@procedimiento, EAX
    RET
    invocacion@main@procedimiento:
    MOV EAX, _a@main@procedimiento
    MOV _b@main@procedimiento, EAX
    CALL procedimiento@main@procedimiento@invocacion
    RET
    procedimiento@main:
    MOV EAX, _b@main@procedimiento
    MOV _a@main@procedimiento, EAX
    MOV EAX, _z@main@procedimiento
    MOV _@aux0, EAX
    FILD _@aux0
    FSTP _@aux0
    FLD _x@main@procedimiento
    FLD _@aux0
    FMUL 
    FSTP _@aux1
    FLD _@aux1
    FSTP _c@main@procedimiento
    CALL invocacion@main@procedimiento
    RET
    END START

----------------------------------------------------------
%% Instruccion:
Caso de prueba:
    LONGINT a,b;
    a = 3_l; 
    b = 4_l;
    FLOAT w; 
    w = 2.0;
    PROC procedimiento(FLOAT x, REF LONGINT z) NI = 3_l { 
        LONGINT a,b;
        FLOAT c; 
        a = b;
        c = x * z;
        PROC invocacion() NI = 2_l {
            b = a;	
            PROC procedimiento() NI = 1_l {
                b = a;
            };
            procedimiento();
        };
        invocacion();
    };
    procedimiento(z:b,x:w);
    
Salida ASM:
    .386
    .model flat, stdcall
    option casemap :none
    include \masm32\include\windows.inc
    include \masm32\include\kernel32.inc
    include \masm32\include\user32.inc
    includelib \masm32\lib\kernel32.lib
    includelib \masm32\lib\user32.lib
    .data
    ERROR_DIVISION_CERO db "Error: no es posible divir por cero.", 0
    ERROR_OVERFLOW_SUMA db "Error: overflow en suma.", 0
    FLOAT_CERO DQ 0.0
    MINIMO_POSITIVO DQ 1.17549435e-38
    MINIMO_NEGATIVO DQ -1.17549435e-38
    MAXIMO_POSITIVO DQ 3.40282347e38
    MAXIMO_NEGATIVO DQ -3.40282347e38
    @aux DD ?
    _a@main@procedimiento dd ?
    _x@main@procedimiento dd ?
    _b@main dd ?
    _b@main@procedimiento dd ?
    _a@main dd ?
    _z@main@procedimiento dd ?
    _w@main dd ?
    _Constante0 dd 1
    _Constante1 dd 2
    _Constante2 dd 3
    _Constante3 dd 4
    _Constante4 dd 2.0
    _c@main@procedimiento dd ?
    _@aux1 dd ?
    _@aux0 dd ?
    .code
    START:
    MOV EAX, _Constante2
    MOV _a@main, EAX
    MOV EAX, _Constante3
    MOV _b@main, EAX
    FLD _Constante4
    FSTP _w@main
    MOV EAX, [_b@main]
    MOV _z@main@procedimiento, EAX
    FLD _w@main
    FSTP _x@main@procedimiento
    CALL procedimiento@main
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    __etiquetaErrorDivCero__:
    invoke MessageBox, NULL, addr ERROR_DIVISION_CERO, addr ERROR_DIVISION_CERO, MB_OK
    invoke ExitProcess, 0
    OVERFLOW_FLOAT:
    FINIT
    FLD @aux
    FCOM MAXIMO_POSITIVO
    FSTSW AX
    SAHF
    JA __etiquetaErrorOverflow__
    FINIT
    FLD @aux
    FCOM MINIMO_POSITIVO
    FSTSW AX
    SAHF
    JA FLOAT_VALIDO
    FINIT
    FLD @aux
    FCOM MAXIMO_NEGATIVO
    FSTSW AX
    SAHF
    JB __etiquetaErrorOverflow__
    FINIT
    FLD @aux
    FCOM MINIMO_NEGATIVO
    FSTSW AX
    SAHF
    JB FLOAT_VALIDO
    FINIT
    FLD @aux
    FCOM FLOAT_CERO
    FSTSW AX
    SAHF
    JE FLOAT_VALIDO
    JMP __etiquetaErrorOverflow__
    FLOAT_VALIDO:
    RET
    procedimiento@main@procedimiento@invocacion:
    MOV EAX, _a@main@procedimiento
    MOV _b@main@procedimiento, EAX
    RET
    invocacion@main@procedimiento:
    MOV EAX, _a@main@procedimiento
    MOV _b@main@procedimiento, EAX
    CALL procedimiento@main@procedimiento@invocacion
    RET
    procedimiento@main:
    MOV EAX, _b@main@procedimiento
    MOV _a@main@procedimiento, EAX
    MOV EAX, _z@main@procedimiento
    MOV _@aux0, EAX
    FILD _@aux0
    FSTP _@aux0
    FLD _x@main@procedimiento
    FLD _@aux0
    FMUL 
    FSTP _@aux1
    FLD _@aux1
    FSTP _c@main@procedimiento
    CALL invocacion@main@procedimiento
    RET
    END START

----------------------------------------------------------
%% Instruccion: Ejemplo division por cero, chequeo comparacion / asignacion / conversiones implicitas.
Caso de prueba:
        LONGINT x1 , x2 , x3;
    x1 = 0_l;
    x2 = 1_l;
    x3 = 0_l;

    FLOAT f1, f2, f3;
    f1 = 1.0;
    f2 = 0.0;
    f3 = 3.0;

    f2 = x1 + f1; %% 0 + 1
    IF (f2 == x2){
        OUT("iguales");
    } ELSE {
    OUT("no iguales");
    }END_IF;


    f1 = 0.0;
    f1 = f3 * 4_l;
    IF (f1 == 12.0){
        OUT("iguales");
    } ELSE {
    OUT("no iguales");
    }END_IF;

    f2 = 0.0;
    f1 = f1 / f2;

Salida ASM:
   .386
    .model flat, stdcall
    option casemap :none
    include \masm32\include\windows.inc
    include \masm32\include\kernel32.inc
    include \masm32\include\user32.inc
    includelib \masm32\lib\kernel32.lib
    includelib \masm32\lib\user32.lib
    .data
    ERROR_DIVISION_CERO db "Error: no es posible divir por cero.", 0
    ERROR_OVERFLOW_SUMA db "Error: overflow en suma.", 0
    FLOAT_CERO DQ 0.0
    MINIMO_POSITIVO DQ 1.17549435e-38
    MINIMO_NEGATIVO DQ -1.17549435e-38
    MAXIMO_POSITIVO DQ 3.40282347e38
    MAXIMO_NEGATIVO DQ -3.40282347e38
    @aux DD ?
    _x1@main dd ?
    _@aux5 dd ?
    _@aux4 dd ?
    _x2@main dd ?
    _f2@main dd ?
    _Constante0 dd 0
    _Cadena0 db "iguales", 0
    _Constante1 dd 1
    _Constante2 dd 0.0
    _Constante3 dd 1.0
    _Constante4 dd 4
    _Constante5 dd 12.0
    _x3@main dd ?
    _Constante6 dd 3.0
    _f3@main dd ?
    _@aux3 dd ?
    _@aux2 dd ?
    _@aux1 dd ?
    _f1@main dd ?
    _Cadena1 db "no iguales", 0
    _@aux0 dd ?
    .code
    START:
    MOV EAX, _Constante0
    MOV _x1@main, EAX
    MOV EAX, _Constante1
    MOV _x2@main, EAX
    MOV EAX, _Constante0
    MOV _x3@main, EAX
    FLD _Constante3
    FSTP _f1@main
    FLD _Constante2
    FSTP _f2@main
    FLD _Constante6
    FSTP _f3@main
    MOV EAX, _x1@main
    MOV _@aux0, EAX
    FILD _@aux0
    FSTP _@aux0
    FLD _@aux0
    FADD _f1@main
    FST @aux
    CALL OVERFLOW_FLOAT
    FSTP _@aux1
    FLD _@aux1
    FSTP _f2@main
    MOV EAX, _x2@main
    MOV _@aux2, EAX
    FILD _@aux2
    FSTP _@aux2
    FINIT
    FLD _f2@main
    FCOMP _@aux2
    FSTSW AX
    SAHF
    JNE L32
    invoke MessageBox, NULL, addr _Cadena0, addr  _Cadena0, MB_OK
    JMP L35
    L32:
    invoke MessageBox, NULL, addr _Cadena1, addr  _Cadena1, MB_OK
    L35:
    FLD _Constante2
    FSTP _f1@main
    MOV EAX, _Constante4
    MOV _@aux3, EAX
    FILD _@aux3
    FSTP _@aux3
    FLD _f3@main
    FLD _@aux3
    FMUL 
    FSTP _@aux4
    FLD _@aux4
    FSTP _f1@main
    FINIT
    FLD _f1@main
    FCOMP _Constante5
    FSTSW AX
    SAHF
    JNE L53
    invoke MessageBox, NULL, addr _Cadena0, addr  _Cadena0, MB_OK
    JMP L56
    L53:
    invoke MessageBox, NULL, addr _Cadena1, addr  _Cadena1, MB_OK
    L56:
    FLD _Constante2
    FSTP _f2@main
    FLD _f1@main
    FLD _f2@main
    FLD FLOAT_CERO
    FCOMP
    FSTSW AX
    SAHF
    JE __etiquetaErrorDivCero__
    FDIV
    FSTP _@aux5
    FLD _@aux5
    FSTP _f1@main
    invoke ExitProcess, 0
    __etiquetaErrorOverflow__:
    invoke MessageBox, NULL, addr ERROR_OVERFLOW_SUMA, addr  ERROR_OVERFLOW_SUMA, MB_OK
    invoke ExitProcess, 0
    __etiquetaErrorDivCero__:
    invoke MessageBox, NULL, addr ERROR_DIVISION_CERO, addr ERROR_DIVISION_CERO, MB_OK
    invoke ExitProcess, 0
    OVERFLOW_FLOAT:
    FINIT
    FLD @aux
    FCOM MAXIMO_POSITIVO
    FSTSW AX
    SAHF
    JA __etiquetaErrorOverflow__
    FINIT
    FLD @aux
    FCOM MINIMO_POSITIVO
    FSTSW AX
    SAHF
    JA FLOAT_VALIDO
    FINIT
    FLD @aux
    FCOM MAXIMO_NEGATIVO
    FSTSW AX
    SAHF
    JB __etiquetaErrorOverflow__
    FINIT
    FLD @aux
    FCOM MINIMO_NEGATIVO
    FSTSW AX
    SAHF
    JB FLOAT_VALIDO
    FINIT
    FLD @aux
    FCOM FLOAT_CERO
    FSTSW AX
    SAHF
    JE FLOAT_VALIDO
    JMP __etiquetaErrorOverflow__
    FLOAT_VALIDO:
    RET
    END START


----------------------------------------------------------

